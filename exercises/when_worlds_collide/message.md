{blue}What the... ? That... that's not the right order. I set the timeout to be one second, so why doesn't it fire after one second? Plus, why doesn't it at least show up first? What gives?!{/blue}

... is exactly what you're thinking right now! Right? Right? Probably. I'm a wee bit psychic, you see. But let's talk about that on another quest, and see what happened here.

First, we have our `setTimeout` function. This is a Web Application API, so on another thread, it sets a timer for one second to fire the function passed to it. So far, so good. Then, we have our `sleep` function. This holds the thread for two seconds. Okay, good, but why didn't our function in `setTimeout` run? Isn't that on another thread, so it should run at the right time?

Well, here's what really happens with `setTimeout`: `setTimeout` doesn't guarantee when something will run. In fact, its only job is to add the function specified to the front of the call stack at the specified time. So, it did indeed add our specified function at the right time to the call stack, but we can't see that happening. When it did add the function, though, there was something already running on our thread: our `sleep` function! So, our function from `setTimeout` had to go just behind that, as `setTimeout` can't interrupt what's running, only add to the call stack. If it could interrupt what's running, very bad things could happen. In our network example, if a function could interrupt a download, then it might accidentally corrupt the download. This could be even worse with file operations, where an important file could be corrupted if a function interrupted a write to a file. With that it mind, `setTimeout` does what it's supposed to do, which is add functions to the front of the call stack; the call stack does what it's supposed to do, which is hold all of the functions for the event loop to grab; and the event loop did what it's supposed to do, which is give the next function for the JS engine to run.

A way to see `setTimeout` is that isn't giving a guarantee of when a function it will, but instead it's giving a {red}minimum time{/red} of when it will run. The specified function will never run earlier than the delay given, but it may run later. In most cases, when you are using sensible APIs, it will run at the delay expected. However, if you aren't careful, and use a long-running synchronous API, you could be blocking others asynchronous APIs!

Let's wrap this up, young wizard. Run `going-loopy` to continue.
